  # frozen_string_literal: true

  ##### This file was generated by Gloss; any changes made here will be overwritten.
  ##### See src/ to make changes

require "pry-byebug"
module Gloss
  class TypeChecker
    Project = Struct.new(:"targets")
    attr_reader(:"steep_target", :"top_level_decls", :env, :rbs_gem_dir)
    def initialize()
      @steep_target = Steep::Project::Target.new(name: "gloss", options:       Steep::Project::Options.new
.tap() { |o|
        o.allow_unknown_constant_assignment=(true)
      }, source_patterns: ["gloss.rb"], ignore_patterns:       Array.new, signature_patterns: ["sig"])
      @top_level_decls = {}
      @rbs_gem_dir = `gem which rbs`.chomp
      env_loader = RBS::EnvironmentLoader.new
      @env = RBS::Environment.from_loader(env_loader)
      project = Steep::Project.new(steepfile_path: Pathname.new(Config.src_dir).realpath)
      project.targets << @steep_target
      loader = Steep::Project::FileLoader.new(project: project)
      # loader.load_signatures
    end
    def run(rb_str)
      begin
        valid_types = check_types(rb_str)
      rescue ParseError => e
        throw(:"error", "")
      rescue  => e
        throw(:"error", "Type checking Error: #{e.message} (#{e.class})")
      end
      unless valid_types
        errors = @steep_target.errors
.map() { |e|
case e
            when Steep::Diagnostic::Ruby::NoMethod
              "Unknown method :#{e.method}, location: #{e.type
.location
.inspect}"
            when Steep::Diagnostic::Ruby::MethodBodyTypeMismatch
              "Invalid method body type - expected: #{e.expected}, actual: #{e.actual}"
            when Steep::Diagnostic::Ruby::IncompatibleArguments
              "Invalid argmuents - method type: #{e.method_type}\nmethod name: #{e.method_type
.method_decls
.first
.method_name}"
            when Steep::Diagnostic::Ruby::ReturnTypeMismatch
              "Invalid return type - expected: #{e.expected}, actual: #{e.actual}"
            when Steep::Diagnostic::Ruby::IncompatibleAssignment
              "Invalid assignment - cannot assign #{e.rhs_type} to type #{e.lhs_type}"
            when Steep::Diagnostic::Ruby::UnexpectedBlockGiven
              "Unexpected block given"
            else
              e.inspect
          end
        }
.join("\n")
        throw(:"error", errors)
      end
true
    end
    def check_types(rb_str)
      @steep_target.add_source("gloss.rb", rb_str)
      @top_level_decls.each() { |_, decl|
        @env.<<(decl)
      }
      @env = @env.resolve_type_names
      @steep_target.instance_variable_set("@environment", env)
      @steep_target.type_check
      (if @steep_target.status
.is_a?(Steep::Project::Target::SignatureErrorStatus)
        throw(:"error", @steep_target.status
.errors
.map() { |e|

          msg = case e
                when Steep::Diagnostic::Signature::UnknownTypeName
                  "Unknown type name: #{e.name.name} (#{e.location.source[/^.*$/]})"
                else
                  e.exception.error_value.value
                end
"  SignatureSyntaxError:\n    Location: #{e.location}\n    Message: \"#{msg}\""        }
.join("\n"))
      end)
      @steep_target.source_files
.each() { |path, f|
        (if f.status
.is_a?(Steep::Project::SourceFile::ParseErrorStatus)
          e = f.status
.error
          throw(:"error", "#{e.class}: #{e.message}")
        end)
      }
@steep_target.status
.is_a?(Steep::Project::Target::TypeCheckStatus) && @steep_target.no_error? && @steep_target.errors
.empty?
    end


     def load_sig_path(path)
      Gloss.logger.debug "Loading signature file for #{path}"
      @steep_target.add_signature path, File.open(path).read
    end
  end
end
