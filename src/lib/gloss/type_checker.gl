# frozen_string_literal: true
      require "pry-byebug"

module Gloss
  class TypeChecker
    Project = Struct.new :targets

    attr_reader :steep_target, :top_level_decls, :env, :rbs_gem_dir

    def initialize
      @steep_target = Steep::Project::Target.new(
        name: "gloss",
        options: Steep::Project::Options.new.tap do |o|
          o.allow_unknown_constant_assignment = true
        end,
        source_patterns: ["gloss.rb"],
        ignore_patterns: Array.new,
        signature_patterns: ["sig"]
      )
      @top_level_decls = {}
      @rbs_gem_dir = `gem which rbs`.chomp
      env_loader = RBS::EnvironmentLoader.new
      @env = RBS::Environment.from_loader(env_loader)
      project = Steep::Project.new(steepfile_path: Pathname.new(Config.src_dir).realpath)
      project.targets << @steep_target
      loader = Steep::Project::FileLoader.new(project: project)
      #loader.load_signatures
    end

    def run(rb_str)
      begin
        valid_types = check_types rb_str
      rescue ParseError => e
        throw :error, ""
      rescue => e
        throw :error, "Type checking Error: #{e.message} (#{e.class})"
      end

      unless valid_types
        errors = @steep_target.errors.map { |e|
          case e
            when Steep::Diagnostic::Ruby::NoMethod
              "Unknown method :#{e.method}, location: #{e.type.location.inspect}"
            when Steep::Diagnostic::Ruby::MethodBodyTypeMismatch
              "Invalid method body type - expected: #{e.expected}, actual: #{e.actual}"
            when Steep::Diagnostic::Ruby::IncompatibleArguments
              <<-ERR
              Invalid argmuents - method type: #{e.method_type}
              method name: #{e.method_type.method_decls.first.method_name}
              ERR
            when Steep::Diagnostic::Ruby::ReturnTypeMismatch
              "Invalid return type - expected: #{e.expected}, actual: #{e.actual}"
            when Steep::Diagnostic::Ruby::IncompatibleAssignment
              "Invalid assignment - cannot assign #{e.rhs_type} to type #{e.lhs_type}"
            when Steep::Diagnostic::Ruby::UnexpectedBlockGiven
              "Unexpected block given"
            else
              e.inspect
            end
        }.join("\n")
        throw :error, errors
      end

      true
    end

    def check_types(rb_str)
      @steep_target.add_source("gloss.rb", rb_str)

      @top_level_decls.each do |_, decl|
        @env << decl
      end
      @env = @env.resolve_type_names

      @steep_target.instance_variable_set("@environment", env)

      @steep_target.type_check

      if @steep_target.status.is_a? Steep::Project::Target::SignatureErrorStatus
        throw :error, @steep_target.status.errors.map { |e|
          msg = case e
                when Steep::Diagnostic::Signature::UnknownTypeName
                  "Unknown type name: #{e.name.name} (#{e.location.source[/^.*$/]})"
                else
                  e.exception.error_value.value
                end
          <<~MSG
            SignatureSyntaxError:
              Location: #{e.location}
              Message: "#{msg}"
          MSG
        }.join("\n")
      end

      @steep_target.source_files.each do |path, f|
        if f.status.is_a? Steep::Project::SourceFile::ParseErrorStatus
          e = f.status.error
          throw :error, "#{e.class}: #{e.message}"
        end
      end

      @steep_target.status.is_a?(Steep::Project::Target::TypeCheckStatus) &&
        @steep_target.no_error? &&
        @steep_target.errors.empty?
    end

    def load_sig_path(path : String)
      Gloss.logger.debug "Loading signature file for #{path}"
      @steep_target.add_signature path, File.open(path).read
    end
  end
end
